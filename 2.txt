ChatGPT 5.2
How can I create the threads, and onliy after they are all allocated, run my code
answer:
You can’t make pthread_create() “pre-allocate everything forever,” but you can do the next best thing:

create all threads up front

synchronize them so they don’t run your real workload until you say “go”

optionally “warm up” libc/pthread allocations before you start your allocator-sensitive phase

This is done with a start barrier (or a mutex+condvar gate).

Option A: pthread_barrier_t (simple)

Main thread creates N workers + itself participates in the barrier. Workers block immediately at the barrier; main releases them only after all are created.

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct {
  pthread_barrier_t *start_barrier;
  // put other args here
} worker_arg_t;

void *worker(void *p) {
  worker_arg_t *a = (worker_arg_t *)p;

  // Thread is created, now wait until everyone is ready.
  pthread_barrier_wait(a->start_barrier);

  // ---- real work starts here ----
  // your code that uses your allocator-sensitive logic
  return NULL;
}

int main(void) {
  const int N = 8;
  pthread_t th[N];
  worker_arg_t args[N];

  pthread_barrier_t start_barrier;
  pthread_barrier_init(&start_barrier, NULL, N + 1); // +1 for main

  // Optional: "warm up" anything that might allocate *before* you start.
  // e.g., call functions you know will be used later, do a dummy malloc/free, etc.

  for (int i = 0; i < N; i++) {
    args[i].start_barrier = &start_barrier;
    if (pthread_create(&th[i], NULL, worker, &args[i]) != 0) {
      perror("pthread_create");
      exit(1);
    }
  }

  // At this point, threads exist but are stuck at the barrier.
  // If pthread/libc needed to allocate during thread creation, it already happened.

  // If you have a “switch” to enter your allocator-sensitive phase, do it now.

  // Release all workers to start real work:
  pthread_barrier_wait(&start_barrier);

  for (int i = 0; i < N; i++) pthread_join(th[i], NULL);
  pthread_barrier_destroy(&start_barrier);
  return 0;
}

What this guarantees

your work code won’t run until after all threads were created

most pthread internal allocations that happen at creation time will have already happened

What it does not guarantee

that pthread/libc will never allocate later (TLS growth, dynamic linking, stdio, locale, etc.)

Option B: mutex + condition variable “gate” (portable, flexible)

This lets the main thread open the gate when ready.

#include <pthread.h>
#include <stdbool.h>

static pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t  cv = PTHREAD_COND_INITIALIZER;
static bool go = false;

void *worker(void *arg) {
  (void)arg;

  pthread_mutex_lock(&m);
  while (!go) pthread_cond_wait(&cv, &m);
  pthread_mutex_unlock(&m);

  // ---- real work starts here ----
  return NULL;
}

int main() {
  // create threads ...
  // warmup ...
  pthread_mutex_lock(&m);
  go = true;
  pthread_cond_broadcast(&cv);
  pthread_mutex_unlock(&m);
  // join threads ...
}

If your goal is “no further allocations after startup”

That’s harder, but doable approximately:

Create all threads early (as above).

Pre-touch / warm up code paths that might allocate:

call your logging once, format strings once, initialize libraries once

do a dummy dlopen/use of anything that lazily loads

Use static TLS where possible and avoid creating new threads later.

Consider interposing malloc so even “late” allocations go through your allocator (LD_PRELOAD / link wrap).

If you tell me your platform (Linux glibc? macOS?), and whether you’re trying to prevent allocations or just keep them out of your heap region, I can suggest the right “hard” approach (e.g., mmap-backed private arena vs full interposition).


